A*寻路就是用来计算玩家行进路径的，通过他可以计算出避开阻挡的最短路径。

A*寻路算法在商业游戏开发重使用很频繁，在2D游戏中使用最多。

### 参数

起点，终点

阻挡区域

### 基本思路

寻找终点周围的点位，排除边界和阻挡

将所有可走的点收纳，并在这些收纳的点中寻找可走的点位，不断持续直到达到起点，但是已经之前已被收纳过的点是不会再计算最优的。

### 详细原理

1.寻路消耗公式：f(寻路消耗)=g(离起点的距离)+h(离终点的距离)

2.开启列表：判断最优的点

3.关闭列表

4.格子对象的父对象

每次从新的点找周围的点时，如果周围的点已经在开启列表或关闭列表中了，我们就不去管他了。

每次往关闭列表中放点时，我们都应该判断这个点是不是和终点一样，如果是一样证明路径找完了，如果不一样则继续找。

路径找完时还远没有结束，因为我们寻找路径时从未判断过阻碍，这就是为什么我们不清除开启列表的原因，我们之后还会倒回来找之前的点。

### 思考：如何判断死路

开启列表都被筛完的时候？

### 具体如何写寻路

1.需求分析

2.类图的梳理

3.核心类的基本结构

4.核心代码实现

5.测试

### 类图成员

类图整理是非常重要的一步

1.寻路管理器（管理所有的格子）

    openlist

    closelist

2.格子类
